### 数组、链表、跳表

#### **数组（Array）**

```
1、数组容量固定、存储数据类型一致的
2、数组是一种顺序存储的线性表，所有元素的内存地址都是连续的。
```

如下一个整型数组，假如

![image-20210923115414232](https://gitee.com/panqiyi/pqimg/raw/master/20210923115414.png)

这些元素在内存中都是连续紧邻分配的，大小一样（如上int的4个字节），可以利用元素的索引（index）可以计算出该元素对应的存储地址，如第三个：110+2*4=118。查找的时间复杂度为O(1)

```
查找：O(1)   根据索引访问特定位置元素
插入：O(n)   平均情况（特殊如插入尾部:O(1)）
删除：O(n)   平均情况（特殊如删除尾部:O(1)）
```

<hr/>

#### **链表（LinkedList）**

```
1、链表存储元素的内存地址是非连续的
2、通过指针将节点与节点连起来
```

链表克服了数组容量固定的不足，对于内存空间的使用更加灵活。但链表相对于数组会使用更多的空间，因为它多了指向其他节点的指针。

```
插入：O(1)
删除：O(1)
查找：O(n)  访问特定位置节点
```

**常见链表分类：**

1. 单链表
2. 双向链表
3. 循环链表
4. 双向循环链表

**单链表：**

<img src="https://gitee.com/panqiyi/pqimg/raw/master/20210923131733.png" alt="image-20210923131733607" style="zoom:80%;" />

链表的定义：

```
根据链表的特点，我们只要在链表中定义头结点即可
```

1、直接使用一个元素节点为头结点

<img src="https://gitee.com/panqiyi/pqimg/raw/master/20210923133404.png" alt="image-20210923133404272" style="zoom:67%;" />

2、使用一个虚拟的节点作为头结点，即我们常说的哨兵

<img src="https://gitee.com/panqiyi/pqimg/raw/master/20210923133511.png" alt="image-20210923133511580" style="zoom:67%;" />

二者区别？

方式一：元素头结点

```java
public class LinkedList {
    //定义节点
    class Node {
        int data; //数据
        Node next; // 下一个节点地址

        public Node(int data) {
            this.data = data;
        }
    }

    Node head = null; // 头结点

    // 链表 （添加元素）
    public  void addNode(int d){
        if (head==null){
            head=new Node(d); // 如果头结点为空，赋值为该新增节点为头结点
        }else {
            // 如果头结点不为空，判断它的next是否为空
            Node tmp=head;
            while (tmp.next!=null){
                tmp=tmp.next; //继续遍历下一个节点，直到next为null
            }
            tmp.next=new Node(d); // next为null指向新添加的节点 new Node(d)
        }
    }
}
```

1、可以看到，当一个元素作为头结点时，每添加一个元素就会判断head头结点是否为空，影响效率。

`if (head==null){
            head.next=new Node(d); // 如果头结点为空，赋值为该新增节点为头结点
        }else {`

2、头结点与其他结点插入逻辑不统一（一个需要判空后再插入，一个不需要判空直接插入）,从程序逻辑性来说不是那么合理（因为结点与结点是平级，添加逻辑理应相同）

方式2: 虚拟头(哨兵)结点

```Java
	//省略节点定义……
	int length = 0; // 链表长度，非必须，可不加
    Node head = new Node(0); // 哨兵头结点
// 链表 （添加元素）
    public void addNode(int d){ 
            Node tmp=head;
            while (tmp.next!=null){
                tmp=tmp.next; //继续遍历下一个节点，直到next为null
            }
            tmp.next=new Node(d); // next为null指向新添加的节点 new Node(d)
        }
    }
```

双向链表;

<img src="https://gitee.com/panqiyi/pqimg/raw/master/20210923150234.png" alt="image-20210923150234121" style="zoom:80%;" />

环形链表：

<img src="https://gitee.com/panqiyi/pqimg/raw/master/20210923145717.png" alt="image-20210923145717419" style="zoom:80%;" />

双向循环链表：

<img src="https://gitee.com/panqiyi/pqimg/raw/master/20210923150419.png" alt="image-20210923150419317" style="zoom:80%;" />

#### 数组与链表的优劣

```
1、数组根据索引随机查找速度快 O(1),但是插入删除慢 O(n)
2、链表插入删除速度快 O(1)，访问查找元素较慢 O(n)

3、
	cpu与内存之间是有多层缓存的，越接近cpu的缓存(cache)速度越快，所以提前把内存的数据加载到缓存中，那么下次cpu直接在缓存中取数据就很快。而根据程序局部性原理,当用了数组的其中一个元素时，那么它地址附近的元素就会被加载到缓存中，提升性能。
	而链表的地址是随机分布的，通过指针联系起来，所以无法利用 程序局部性原理 来提前加载到缓存中来提升程序性能。
```

<img src="https://gitee.com/panqiyi/pqimg/raw/master/20210923152445.png" alt="image-20210923152445804" style="zoom:67%;" />